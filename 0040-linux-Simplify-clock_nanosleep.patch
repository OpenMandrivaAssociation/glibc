From 55399535c147d8a0e109c24435628aa6213480fc Mon Sep 17 00:00:00 2001
From: Adhemerval Zanella <adhemerval.zanella@linaro.org>
Date: Fri, 10 Jul 2020 09:54:35 -0300
Subject: [PATCH 040/267] linux: Simplify clock_nanosleep

With arch-syscall.h it can now assumes the existance of either
__NR_clock_nanosleep or __NR_clock_nanosleep_time64.  The 32-bit
time_t support is now only build for !__ASSUME_TIME64_SYSCALLS.

Checked on x86_64-linux-gnu and i686-linux-gnu (on 5.4 and on 4.15
kernel).

Reviewed-by: Lukasz Majewski <lukma@denx.de>
---
 sysdeps/unix/sysv/linux/clock_nanosleep.c | 33 ++++++++---------------
 1 file changed, 11 insertions(+), 22 deletions(-)

diff --git a/sysdeps/unix/sysv/linux/clock_nanosleep.c b/sysdeps/unix/sysv/linux/clock_nanosleep.c
index cc7a09569d..6ad3321435 100644
--- a/sysdeps/unix/sysv/linux/clock_nanosleep.c
+++ b/sysdeps/unix/sysv/linux/clock_nanosleep.c
@@ -30,8 +30,6 @@ int
 __clock_nanosleep_time64 (clockid_t clock_id, int flags, const struct __timespec64 *req,
                           struct __timespec64 *rem)
 {
-  int r;
-
   if (clock_id == CLOCK_THREAD_CPUTIME_ID)
     return EINVAL;
   if (clock_id == CLOCK_PROCESS_CPUTIME_ID)
@@ -39,22 +37,15 @@ __clock_nanosleep_time64 (clockid_t clock_id, int flags, const struct __timespec
 
   /* If the call is interrupted by a signal handler or encounters an error,
      it returns a positive value similar to errno.  */
-#ifdef __ASSUME_TIME64_SYSCALLS
-# ifndef __NR_clock_nanosleep_time64
-#  define __NR_clock_nanosleep_time64 __NR_clock_nanosleep
-# endif
-  r = INTERNAL_SYSCALL_CANCEL (clock_nanosleep_time64, clock_id,
-                               flags, req, rem);
-#else
-# ifdef __NR_clock_nanosleep_time64
-  r = INTERNAL_SYSCALL_CANCEL (clock_nanosleep_time64, clock_id,
-                               flags, req, rem);
-
-  if (! INTERNAL_SYSCALL_ERROR_P (r))
-    return 0;
-  if (INTERNAL_SYSCALL_ERRNO (r) != ENOSYS)
-    return INTERNAL_SYSCALL_ERRNO (r);
-# endif /* __NR_clock_nanosleep_time64 */
+#ifndef __NR_clock_nanosleep_time64
+# define __NR_clock_nanosleep_time64 __NR_clock_nanosleep
+#endif
+  int r = INTERNAL_SYSCALL_CANCEL (clock_nanosleep_time64, clock_id,
+				   flags, req, rem);
+
+#ifndef __ASSUME_TIME64_SYSCALLS
+  if (r == 0 || r != -ENOSYS)
+    return -r;
 
   if (! in_time_t_range (req->tv_sec))
     {
@@ -68,14 +59,12 @@ __clock_nanosleep_time64 (clockid_t clock_id, int flags, const struct __timespec
                                &ts32, &tr32);
   if (INTERNAL_SYSCALL_ERROR_P (r))
     {
-      if (INTERNAL_SYSCALL_ERRNO (r) == EINTR && rem != NULL
-	  && (flags & TIMER_ABSTIME) == 0)
+      if (r == -EINTR && rem != NULL && (flags & TIMER_ABSTIME) == 0)
 	*rem = valid_timespec_to_timespec64 (tr32);
     }
 #endif /* __ASSUME_TIME64_SYSCALLS */
 
-  return (INTERNAL_SYSCALL_ERROR_P (r)
-	  ? INTERNAL_SYSCALL_ERRNO (r) : 0);
+  return -r;
 }
 
 #if __TIMESIZE != 64
-- 
2.29.0

