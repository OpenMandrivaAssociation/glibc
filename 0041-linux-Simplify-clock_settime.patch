From ff6228d5c6b0fa34ecb51228be57392649ffc88e Mon Sep 17 00:00:00 2001
From: Adhemerval Zanella <adhemerval.zanella@linaro.org>
Date: Fri, 10 Jul 2020 10:04:14 -0300
Subject: [PATCH 041/267] linux: Simplify clock_settime

With arch-syscall.h it can now assumes the existance of either
__NR_clock_settime or __NR_clock_settime_time64.  The 32-bit
time_t support is now only build for !__ASSUME_TIME64_SYSCALLS.

Checked on x86_64-linux-gnu and i686-linux-gnu (on 5.4 and on 4.15
kernel).

Reviewed-by: Lukasz Majewski <lukma@denx.de>
---
 sysdeps/unix/sysv/linux/clock_settime.c | 18 +++++++++---------
 1 file changed, 9 insertions(+), 9 deletions(-)

diff --git a/sysdeps/unix/sysv/linux/clock_settime.c b/sysdeps/unix/sysv/linux/clock_settime.c
index ebda871f4c..ce0bf622c0 100644
--- a/sysdeps/unix/sysv/linux/clock_settime.c
+++ b/sysdeps/unix/sysv/linux/clock_settime.c
@@ -32,17 +32,15 @@ __clock_settime64 (clockid_t clock_id, const struct __timespec64 *tp)
       return -1;
     }
 
-#ifdef __ASSUME_TIME64_SYSCALLS
-# ifndef __NR_clock_settime64
-#  define __NR_clock_settime64 __NR_clock_settime
-# endif
-  return INLINE_SYSCALL_CALL (clock_settime64, clock_id, tp);
-#else
-# ifdef __NR_clock_settime64
+#ifndef __NR_clock_settime64
+# define __NR_clock_settime64 __NR_clock_settime
+#endif
   int ret = INLINE_SYSCALL_CALL (clock_settime64, clock_id, tp);
+
+#ifndef __ASSUME_TIME64_SYSCALLS
   if (ret == 0 || errno != ENOSYS)
     return ret;
-# endif
+
   if (! in_time_t_range (tp->tv_sec))
     {
       __set_errno (EOVERFLOW);
@@ -50,8 +48,10 @@ __clock_settime64 (clockid_t clock_id, const struct __timespec64 *tp)
     }
 
   struct timespec ts32 = valid_timespec64_to_timespec (*tp);
-  return INLINE_SYSCALL_CALL (clock_settime, clock_id, &ts32);
+  ret = INLINE_SYSCALL_CALL (clock_settime, clock_id, &ts32);
 #endif
+
+  return ret;
 }
 
 #if __TIMESIZE != 64
-- 
2.29.0

