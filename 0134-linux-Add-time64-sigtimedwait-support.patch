From 94a83d86676d0fbea78cdaa8e5bab1db155c7504 Mon Sep 17 00:00:00 2001
From: Adhemerval Zanella <adhemerval.zanella@linaro.org>
Date: Mon, 6 Jul 2020 17:14:42 -0300
Subject: [PATCH 134/267] linux: Add time64 sigtimedwait support

The syscall __NR_sigtimedwait_time64 (for 32-bit) or __NR_sigtimedwait
(for 64-bit) is used as default.  The 32-bit fallback is used iff
__ASSUME_TIME64_SYSCALLS is not defined, which assumes the kernel ABI
provides either __NR_rt_sigtimedwait (32-bit time_t).

Checked on x86_64-linux-gnu and i686-linux-gnu.

Reviewed-by: Alistair Francis <alistair.francis@wdc.com>
---
 include/signal.h                       |  8 +++++
 sysdeps/unix/sysv/linux/sigtimedwait.c | 50 +++++++++++++++++++++-----
 2 files changed, 50 insertions(+), 8 deletions(-)

diff --git a/include/signal.h b/include/signal.h
index b4ee02d153..544d701bce 100644
--- a/include/signal.h
+++ b/include/signal.h
@@ -38,6 +38,14 @@ extern int __sigwait (const sigset_t *__set, int *__sig);
 libc_hidden_proto (__sigwait)
 extern int __sigwaitinfo (const sigset_t *__set, siginfo_t *__info);
 libc_hidden_proto (__sigwaitinfo)
+#if __TIMESIZE == 64
+# define __sigtimedwait64 __sigtimedwait
+#else
+# include <struct___timespec64.h>
+extern int __sigtimedwait64 (const sigset_t *__set, siginfo_t *__info,
+			     const struct __timespec64 *__timeout);
+libc_hidden_proto (__sigtimedwait64)
+#endif
 extern int __sigtimedwait (const sigset_t *__set, siginfo_t *__info,
 			   const struct timespec *__timeout);
 libc_hidden_proto (__sigtimedwait)
diff --git a/sysdeps/unix/sysv/linux/sigtimedwait.c b/sysdeps/unix/sysv/linux/sigtimedwait.c
index f2ef3aad45..4405606571 100644
--- a/sysdeps/unix/sysv/linux/sigtimedwait.c
+++ b/sysdeps/unix/sysv/linux/sigtimedwait.c
@@ -15,20 +15,38 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
-#include <errno.h>
 #include <signal.h>
-#include <string.h>
-#include <sysdep-cancel.h>
+#include <sysdep.h>
 
 int
-__sigtimedwait (const sigset_t *set, siginfo_t *info,
-		const struct timespec *timeout)
+__sigtimedwait64 (const sigset_t *set, siginfo_t *info,
+		  const struct __timespec64 *timeout)
 {
-  /* XXX The size argument hopefully will have to be changed to the
-     real size of the user-level sigset_t.  */
-  int result = SYSCALL_CANCEL (rt_sigtimedwait, set, info, timeout,
+#ifndef __NR_rt_sigtimedwait_time64
+# define __NR_rt_sigtimedwait_time64 __NR_rt_sigtimedwait
+#endif
+  int result = SYSCALL_CANCEL (rt_sigtimedwait_time64, set, info, timeout,
 			       __NSIG_BYTES);
 
+#ifndef __ASSUME_TIME64_SYSCALLS
+  if (result != 0 && errno == ENOSYS)
+    {
+      struct timespec ts32, *pts32 = NULL;
+      if (timeout != NULL)
+	{
+	  if (! in_time_t_range (timeout->tv_sec))
+	    {
+	      __set_errno (EINVAL);
+	      return -1;
+	    }
+	  ts32 = valid_timespec64_to_timespec (*timeout);
+	  pts32 = &ts32;
+	}
+      result = SYSCALL_CANCEL (rt_sigtimedwait, set, info, pts32,
+			       __NSIG_BYTES);
+    }
+#endif
+
   /* The kernel generates a SI_TKILL code in si_code in case tkill is
      used.  tkill is transparently used in raise().  Since having
      SI_TKILL as a code is useful in general we fold the results
@@ -38,5 +56,21 @@ __sigtimedwait (const sigset_t *set, siginfo_t *info,
 
   return result;
 }
+#if __TIMESIZE != 64
+libc_hidden_def (__sigtimedwait64)
+
+int
+__sigtimedwait (const sigset_t *set, siginfo_t *info,
+		const struct timespec *timeout)
+{
+  struct __timespec64 ts64, *pts64 = NULL;
+  if (timeout != NULL)
+    {
+      ts64 = valid_timespec_to_timespec64 (*timeout);
+      pts64 = &ts64;
+    }
+  return __sigtimedwait64 (set, info, pts64);
+}
+#endif
 libc_hidden_def (__sigtimedwait)
 weak_alias (__sigtimedwait, sigtimedwait)
-- 
2.29.0

