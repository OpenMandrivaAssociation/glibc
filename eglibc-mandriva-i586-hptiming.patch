--- libc/elf/rtld.c.hpt~	2012-12-01 22:41:05.289510763 +0100
+++ libc/elf/rtld.c	2012-12-01 22:41:34.631828566 +0100
@@ -16,6 +16,9 @@
    License along with the GNU C Library; if not, see
    <http://www.gnu.org/licenses/>.  */
 
+/* Early statistics require high-precision timing.  */
+#define NEED_HP_TIMING_HWCAP_AVAIL 1
+
 #include <gnu/option-groups.h>
 #include <errno.h>
 #include <dlfcn.h>
@@ -191,6 +194,12 @@ static void dl_main (const ElfW(Phdr) *p
 static struct libname_list _dl_rtld_libname;
 static struct libname_list _dl_rtld_libname2;
 
+/* Run-time detect availability of high-precision timer?  */
+#ifdef HP_TIMING_HWCAP_AVAIL
+# undef HP_TIMING_AVAIL
+# define HP_TIMING_AVAIL HP_TIMING_HWCAP_AVAIL
+#endif
+
 /* We expect less than a second for relocation.  */
 #ifdef HP_SMALL_TIMING_AVAIL
 # undef HP_TIMING_AVAIL
@@ -322,9 +331,8 @@ _dl_start_final (void *arg, struct dl_st
 
 #endif
 
-#if HP_TIMING_AVAIL
-  HP_TIMING_NOW (GL(dl_cpuclock_offset));
-#endif
+  if (HP_TIMING_AVAIL)
+    HP_TIMING_NOW (GL(dl_cpuclock_offset));
 
   /* Initialize the stack end variable.  */
   __libc_stack_end = __builtin_frame_address (0);
--- libc/sysdeps/generic/ldsodefs.h.hpt~	2012-05-26 19:46:57.000000000 +0200
+++ libc/sysdeps/generic/ldsodefs.h	2012-12-01 22:41:05.382511769 +0100
@@ -417,7 +417,7 @@ struct rtld_global
   /* The object to be initialized first.  */
   EXTERN struct link_map *_dl_initfirst;
 
-#if HP_TIMING_AVAIL || HP_SMALL_TIMING_AVAIL
+#if HP_TIMING_AVAIL || HP_SMALL_TIMING_AVAIL || defined HP_TIMING_HWCAP_AVAIL
   /* Start time on CPU clock.  */
   EXTERN hp_timing_t _dl_cpuclock_offset;
 #endif
@@ -638,7 +638,7 @@ struct rtld_global_ro
   /* All search directories defined at startup.  */
   EXTERN struct r_search_path_elem *_dl_init_all_dirs;
 
-#if HP_TIMING_AVAIL || HP_SMALL_TIMING_AVAIL
+#if HP_TIMING_AVAIL || HP_SMALL_TIMING_AVAIL || defined HP_TIMING_HWCAP_AVAIL
   /* Overhead of a high-precision timing measurement.  */
   EXTERN hp_timing_t _dl_hp_timing_overhead;
 #endif
--- libc/sysdeps/i386/i586/hp-timing.c.hpt~	2012-12-01 22:41:05.382511769 +0100
+++ libc/sysdeps/i386/i586/hp-timing.c	2012-12-01 22:41:05.382511769 +0100
@@ -0,0 +1,2 @@
+/* We can use the i686 implementation without changes.  */
+#include <sysdeps/i386/i686/hp-timing.c>
--- libc/sysdeps/i386/i586/hp-timing.h.hpt~	2012-12-01 22:41:05.382511769 +0100
+++ libc/sysdeps/i386/i586/hp-timing.h	2012-12-01 22:41:05.382511769 +0100
@@ -0,0 +1,43 @@
+#ifndef _HP_HWCAP_TIMING_H
+#define _HP_HWCAP_TIMING_H 1
+
+/* We can use the i686 implementation with slight changes.  */
+#include <sysdeps/i386/i686/hp-timing.h>
+
+/* We need the definition of HWCAP_I386_TSC.  */
+#include <sysdeps/i386/dl-hwcapinfo.h>
+
+/* We need to perform a runtime check for the timestamp register.  */
+#undef  HP_TIMING_AVAIL
+#define HP_TIMING_AVAIL (0)
+
+/* HP_TIMING_HWCAP_AVAIL: this macro performs a run-time check for the
+   capability.  */
+#define HP_TIMING_HWCAP_AVAIL (_dl_hp_timing_avail())
+
+/* Perform the TSC check.  */
+#ifdef NEED_HP_TIMING_HWCAP_AVAIL
+static inline
+unsigned int
+_dl_cpuid_edx (unsigned int op)
+{
+  unsigned int edx;
+  __asm__ __volatile__("push %%ebx ; cpuid ; pop %%ebx"
+		       : "=d" (edx) : "a" (op) : "ecx");
+  return edx;
+}
+
+static int
+internal_function
+_dl_hp_timing_avail (void)
+{
+  static int has_tsc = -1;
+
+  if (__builtin_expect (has_tsc == -1, 0))
+    has_tsc = (_dl_cpuid_edx(1) & HWCAP_I386_TSC) == HWCAP_I386_TSC;
+
+  return has_tsc;
+}
+#endif
+
+#endif /* hp-timing.h */
--- libc/sysdeps/i386/i586/Makefile.hpt~	2012-12-01 22:41:05.382511769 +0100
+++ libc/sysdeps/i386/i586/Makefile	2012-12-01 22:41:05.382511769 +0100
@@ -0,0 +1,4 @@
+ifeq ($(subdir),csu)
+sysdep_routines += hp-timing
+static-only-routines += hp-timing
+endif
