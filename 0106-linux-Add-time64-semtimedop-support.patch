From 7c437d37789939a1411da0c04f748384bc5aee59 Mon Sep 17 00:00:00 2001
From: Adhemerval Zanella <adhemerval.zanella@linaro.org>
Date: Mon, 6 Jul 2020 17:40:34 -0300
Subject: [PATCH 106/267] linux: Add time64 semtimedop support

Either the __NR_semtimedop_time64 (for 32-bit) or the __NR_semtimedop
(for 64-bit) syscall is used as default.  The 32-bit fallback is used
iff __ASSUME_TIME64_SYSCALLS is not defined, which assumes the kernel
ABI provides either __NR_ipc or __NR_semtimeop (for 32-bit time_t).

Checked on x86_64-linux-gnu and i686-linux-gnu (on 5.4 and on 4.15
kernel).

Reviewed-by: Alistair Francis <alistair.francis@wdc.com>
---
 sysdeps/unix/sysv/linux/include/sys/sem.h |  6 +++
 sysdeps/unix/sysv/linux/semtimedop.c      | 57 +++++++++++++++++++----
 2 files changed, 55 insertions(+), 8 deletions(-)

diff --git a/sysdeps/unix/sysv/linux/include/sys/sem.h b/sysdeps/unix/sysv/linux/include/sys/sem.h
index a9151e057d..f369c6b6d3 100644
--- a/sysdeps/unix/sysv/linux/include/sys/sem.h
+++ b/sysdeps/unix/sysv/linux/include/sys/sem.h
@@ -7,9 +7,15 @@ __typeof__ (semtimedop) __semtimedop attribute_hidden;
 
 #if __TIMESIZE == 64
 # define __semctl64 __semctl
+# define __semtimedop64 __semtimedop
 #else
+# include <struct___timespec64.h>
+
 extern int __semctl64 (int semid, int semnum, int cmd, ...);
 libc_hidden_proto (__semctl64);
+extern int __semtimedop64 (int semid, struct sembuf *sops, size_t nsops,
+			   const struct __timespec64 *tmo);
+libc_hidden_proto (__semtimedop64);
 #endif
 
 # endif
diff --git a/sysdeps/unix/sysv/linux/semtimedop.c b/sysdeps/unix/sysv/linux/semtimedop.c
index 6fdde09bad..56121fb0bf 100644
--- a/sysdeps/unix/sysv/linux/semtimedop.c
+++ b/sysdeps/unix/sysv/linux/semtimedop.c
@@ -22,18 +22,59 @@
 #include <errno.h>
 
 /* Perform user-defined atomical operation of array of semaphores.  */
+int
+__semtimedop64 (int semid, struct sembuf *sops, size_t nsops,
+		const struct __timespec64 *timeout)
+{
+#if defined __ASSUME_DIRECT_SYSVIPC_SYSCALLS
+# ifndef __NR_semtimedop_time64
+#  define __NR_semtimedop_time64 __NR_semtimedop
+# endif
+  int r = INLINE_SYSCALL_CALL (semtimedop_time64, semid, sops, nsops,
+			       timeout);
+#else
+  int r = INLINE_SYSCALL_CALL (ipc, IPCOP_semtimedop, semid,
+			       SEMTIMEDOP_IPC_ARGS (nsops, sops, timeout));
+#endif
+
+#ifndef __ASSUME_TIME64_SYSCALLS
+  if (r == 0 || errno != ENOSYS)
+    return r;
+
+  struct timespec ts32, *pts32 = NULL;
+  if (timeout != NULL)
+    {
+      if (! in_time_t_range (timeout->tv_sec))
+	{
+	  __set_errno (EINVAL);
+	  return -1;
+	}
+      ts32 = valid_timespec64_to_timespec (*timeout);
+      pts32 = &ts32;
+    }
+# if defined __ASSUME_DIRECT_SYSVIPC_SYSCALLS
+  r = INLINE_SYSCALL_CALL (semtimedop, semid, sops, nsops, pts32);
+# else
+  r = INLINE_SYSCALL_CALL (ipc, IPCOP_semtimedop, semid,
+			   SEMTIMEDOP_IPC_ARGS (nsops, sops, pts32));
+# endif
+#endif /* __ASSUME_TIME64_SYSCALLS  */
+  return r;
+}
+#if __TIMESIZE != 64
+libc_hidden_def (__semtimedop64)
 
 int
 __semtimedop (int semid, struct sembuf *sops, size_t nsops,
 	      const struct timespec *timeout)
 {
-  /* semtimedop wire-up syscall is not exported for 32-bit ABIs (they have
-     semtimedop_time64 instead with uses a 64-bit time_t).  */
-#if defined __ASSUME_DIRECT_SYSVIPC_SYSCALLS && defined __NR_semtimedop
-  return INLINE_SYSCALL_CALL (semtimedop, semid, sops, nsops, timeout);
-#else
-  return INLINE_SYSCALL_CALL (ipc, IPCOP_semtimedop, semid,
-			      SEMTIMEDOP_IPC_ARGS (nsops, sops, timeout));
-#endif
+  struct __timespec64 ts64, *pts64 = NULL;
+  if (timeout != NULL)
+    {
+      ts64 = valid_timespec_to_timespec64 (*timeout);
+      pts64 = &ts64;
+    }
+  return __semtimedop64 (semid, sops, nsops, pts64);
 }
+#endif
 weak_alias (__semtimedop, semtimedop)
-- 
2.29.0

