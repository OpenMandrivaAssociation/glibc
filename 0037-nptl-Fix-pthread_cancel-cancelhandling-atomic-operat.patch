From 68d3a9a69696b46f2e552330dd0de5512c36302d Mon Sep 17 00:00:00 2001
From: Adhemerval Zanella <adhemerval.zanella@linaro.org>
Date: Wed, 20 Apr 2022 12:01:43 -0300
Subject: [PATCH 037/127] nptl: Fix pthread_cancel cancelhandling atomic
 operations

The 404656009b reversion did not setup the atomic loop to set the
cancel bits correctly.  The fix is essentially what pthread_cancel
did prior 26cfbb7162ad.

Checked on x86_64-linux-gnu and aarch64-linux-gnu.

(cherry picked from commit 62be9681677e7ce820db721c126909979382d379)
---
 nptl/pthread_cancel.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/nptl/pthread_cancel.c b/nptl/pthread_cancel.c
index c76882e279..e67b2df5cc 100644
--- a/nptl/pthread_cancel.c
+++ b/nptl/pthread_cancel.c
@@ -121,6 +121,7 @@ __pthread_cancel (pthread_t th)
   int newval;
   do
     {
+    again:
       newval = oldval | CANCELING_BITMASK | CANCELED_BITMASK;
       if (oldval == newval)
 	break;
@@ -134,7 +135,7 @@ __pthread_cancel (pthread_t th)
 	  int newval2 = oldval | CANCELING_BITMASK;
 	  if (!atomic_compare_exchange_weak_acquire (&pd->cancelhandling,
 						     &oldval, newval2))
-	    continue;
+	    goto again;
 
 	  if (pd == THREAD_SELF)
 	    /* This is not merely an optimization: An application may
-- 
2.36.1

